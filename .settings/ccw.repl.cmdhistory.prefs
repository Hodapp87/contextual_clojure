cmdhistory=["(+ 1 2)" "(-main)" "(ns contextual.core)" "(-main)" "(+ 1 2)" "(ns contextual.core)" "(-main)" "(ns contextual.core)" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [shapefn \#(rect 400 400 100 100)\\n        rot 0.0\\n        tx 100.0\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [shapefn \#(rect 400 400 100 100)\\n        rot 0.0\\n        tx 0.0\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [shapefn \#(rect 0 0 100 100)\\n        rot 0.0\\n        tx 101.0\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [shapefn \#(rect 0 0 100 100)\\n        rot 0.0\\n        tx 110.0\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [shapefn \#(rect 0 0 100 100)\\n        rot 0.1\\n        tx 110.0\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [shapefn \#(rect 0 0 100 100)\\n        rot 0.6\\n        tx 110.0\\n        ty 0.0\\n        sx 0.7\\n        sy 0.7]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [side 200\\n        shapefn \#(rect 0 0 side side)\\n        rot 0.6\\n        tx (* 1.1 side)\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [side 200\\n        shapefn \#(rect 0 0 side side)\\n        rot 0.6\\n        tx (* 1.2 side)\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]  \\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(ns contextual.core)" "(-main)" "(defn draw []\\n  (stroke 255)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot 0.6\\n        tx (* 1.2 side)\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (stroke 255)\\n  (fill 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot 0.6\\n        tx (* 1.2 side)\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(ns contextual.core)" "(-main)" "(defn draw []\\n  (stroke 255)\\n  (fill 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (* (/ mouseX 800) 3.14)\\n        tx (* 1.2 side)\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn draw []\\n  (background 0)\\n  (stroke 255)\\n  (fill 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (* (/ mouseX 800) 3.14)\\n        tx (* 1.2 side)\\n        ty 0.0\\n        sx 0.6\\n        sy 0.6]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn setup []\\n  (smooth)\\n  (frame-rate 60)\\n  (set-state\! \:mouse-position (atom [0 0]))\\n  (background 0))" "(ns contextual.core)" "(-main)" "(defn draw []\\n  (background 0)\\n  (stroke 255)\\n  (fill 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        tx (* 1.2 side)\\n        ty 0.0\\n        sx (/ mouseY 1000)\\n        sy sx]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (background 0)\\n  (stroke 255)\\n  (fill 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 1000)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (background 0)\\n  (stroke 255)\\n  (fill 0 0 0 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 200\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 1000)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw []\\n  (background 0)\\n  (stroke 255)\\n  (fill 0 0 0 0)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 1000)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn draw []\\n  (background 0)\\n  (stroke 0 0 0 0)\\n  (fill 0 127 127 127)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 1000)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn draw []\\n  (background 0)\\n  (stroke 0 0 0 0)\\n  (fill 0 127 127 127)\\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn recurse [shapefn rot tx ty sx sy]\\n  (defn rec [global_sx global_sy]\\n    (if (or (> global_sx 0.005) (> global_sy 0.005))\\n      (do (shapefn)\\n          (translate tx ty)\\n          (rotate rot)\\n          (scale sx sy)\\n          ; sx2, sy2 keep track of global scale so that we know when to bail out.\\n          (rec (* global_sx sx)\\n               (* global_sy sy)))))\\n  ; We save our current matrix, and let 'rec' apply everything cumulatively.\\n  (push-matrix)\\n  (rec 1.0 1.0)\\n  ; Then return to where we started\:\\n  (pop-matrix))" "(defn draw []\\n  (background 0)\\n  (stroke 0 0 0 0)\\n  (fill 0 127 127 64) \\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn draw_kaleid []\\n  (background 0)\\n  (stroke 0 0 0 0)\\n  (fill 0 127 127 64) \\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn draw draw_kaleid)" "(defn -main []\\n  (defsketch example\\n    \:title \\"Recursion\\"\\n    \:setup setup\\n    \:draw draw_kaleid\\n    \:mouse-moved mouse-moved\\n    \:size [800 800]))" "(-main)" "(defn draw_kaleid []\\n  (background 0)\\n  (stroke 0 0 0 0)\\n  (fill 127 0 0 64) \\n  ;(stroke-weight (random 10))       ;;Set the stroke thickness randomly\\n  ;(fill (random 255))               ;;Set the fill colour to a random grey\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw_kaleid []\\n  (background 0)\\n  (stroke 0 0 0 255)\\n  (fill 127 0 0 64) \\n  (stroke-weight 2)\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw_kaleid []\\n  (background 0)\\n  (stroke 0 0 0 255)\\n  (fill 127 0 0 64) \\n  (stroke-weight 2)\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn draw_kaleid []\\n  (background 0)\\n  (stroke 0 0 0 255)\\n  (fill 127 0 0 64) \\n  (stroke-weight 2)\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX screen-x) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(-main)" "(defn start []\\n (defsketch example\\n    \:title \\"Recursion\\"\\n    \:setup setup\\n    \:draw draw_kaleid\\n    \:mouse-moved mouse-moved\\n    \:size [800 800]))" "(defn draw_kaleid []\\n  (background 0)\\n  (stroke 0 0 0 255)\\n  (fill 127 0 0 64) \\n  (stroke-weight 2)\\n  (let [[mouseX mouseY] @(state \:mouse-position)\\n        side 400\\n        shapefn \#(rect (/ side -2) (/ side -2) side side)\\n        rot (- (* (/ mouseX 800) 6.28) 3.14)\\n        sx (/ mouseY 900)\\n        sy sx\\n        tx (* sx side)\\n        ty 0.0]\\n    (translate (/ side 2) (/ side 2))\\n    (recurse shapefn rot tx ty sx sy)))" "(defn -main []\\n  start)" "(-main)" "(defn start []\\n (defsketch example\\n    \:title \\"Recursion\\"\\n    \:setup setup\\n    \:draw draw_kaleid\\n    \:mouse-moved mouse-moved\\n    \:size [800 800]))" "(defn -main []\\n  start)" "(-main)" "(ns contextual.core)" "(-main)" "(defn -main []\\n  (start))" "(-main)" "(defn start []\\n  (let [width 800\\n        height 800]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      (stroke 0 0 0 255)\\n      (fill 127 0 0 64) \\n      (stroke-weight 2)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(defn -main []\\n  (start))" "(-main)" "(defn start []\\n  (let [width 800\\n        height 800]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      (stroke 0 0 0 255)\\n      (fill 255 50 50 64) \\n      (stroke-weight 2)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 800\\n        height 800]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      (stroke 0 0 0 255)\\n      (fill 255 0 0 32) \\n      (stroke-weight 2)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 1000\\n        height 1000]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      (stroke 0 0 0 255)\\n      (fill 255 0 0 32) \\n      (stroke-weight 2)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(doc defsketch)" "(doc sketch)" "(defn start []\\n  (let [width 1000\\n        height 1000]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      (stroke 0 0 0 255)\\n      (fill 255 0 0 32) \\n      (stroke-weight 2)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 1000\\n        height 1000]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 255 0 0 32) \\n      ;(stroke-weight 2)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 1000\\n        height 1000]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 255 0 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 1000\\n        height 1000]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(defn -main []\\n  (start))" "(defn start []\\n  (let [width 1000\\n        height 1000]\\n    ; One demo I rather like, albeit simple. Set the screen to 800x800 and move\\n    ; the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side (/ width 2)\\n            shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(ns contextual.core)" "(-main)" "(+ 1 2)" "(use contextual.core)" "(ns contextual.core)" "(-main)" "(defn square []\\n  (rect -0.5 0.5 1 1))" "(defn circle []\\n  (ellipse 0 0 0.5 0.5))" "(defn start []\\n  (let [width 500\\n        height 500]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn square []\\n  (rect -0.5 -0.5 1 1))" "(defn start []\\n  (let [width 500\\n        height 500]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    ; r,g,b here are the fill color.\\n    (defn draw_kaleid2 []\\n      (background 0)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (fill 0 255 0 32) \\n        (recurse shapefn rot tx ty sx sy)\\n        (fill 0 0 255 32)\\n        (recurse shapefn rot -tx -ty sx sy)))\\n  (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid2\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(defn start []\\n  (let [width 500\\n        height 500]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    ; r,g,b here are the fill color.\\n    (defn draw_kaleid2 []\\n      (background 0)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (fill 0 255 0 32) \\n        (recurse shapefn rot tx ty sx sy)\\n        (fill 0 0 255 32)\\n        (recurse shapefn rot (- tx) (- ty) sx sy)))\\n  (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid2\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 500\\n        height 500]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    ; r,g,b here are the fill color.\\n    (defn draw_kaleid2 []\\n      (background 0)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (translate (/ width 2) (/ width 2))\\n        (scale (/ width 2) (/ width 2))\\n        (fill 0 255 0 32) \\n        (recurse shapefn rot tx ty sx sy)\\n        (fill 0 0 255 32)\\n        (recurse shapefn rot (- tx) (- ty) sx sy)))\\n  (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid2\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 500\\n        height 500]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    ; r,g,b here are the fill color.\\n    (defn draw_kaleid2 []\\n      (background 0)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (translate (/ width 2) (/ width 2))\\n        (scale (/ width 2) (/ width 2))\\n        (fill 0 255 0 32) \\n        (recurse shapefn rot tx ty sx sy)\\n        (fill 0 0 255 32)\\n        (recurse shapefn (* rot 2) (- tx) (- ty) sx sy)))\\n  (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid2\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(defn start []\\n  (let [width 800\\n        height 800]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    ; r,g,b here are the fill color.\\n    (defn draw_kaleid2 []\\n      (background 0)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (translate (/ width 2) (/ width 2))\\n        (scale (/ width 2) (/ width 2))\\n        (fill 0 255 0 32) \\n        (recurse shapefn rot tx ty sx sy)\\n        (fill 0 0 255 32)\\n        (recurse shapefn (* rot 2) (- tx) (- ty) sx sy)))\\n  (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid2\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))" "(-main)" "(doc doc)" "(in-ns 'contextual.core)\\n(defn start []\\n  (let [width 800\\n        height 800]\\n    ; One demo I rather like, albeit simple. Move the mouse around a bit.\\n    (defn draw_kaleid []\\n      (background 0)\\n      ;(stroke 0 0 0 255)\\n      (fill 0 255 0 32) \\n      ;(stroke-weight 2)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (scale width width)\\n        (recurse shapefn rot tx ty sx sy)))\\n    ; r,g,b here are the fill color.\\n    (defn draw_kaleid2 []\\n      (background 0)\\n      (no-stroke)\\n      (let [[mouseX mouseY] @(state \:mouse-position)\\n            side 1\\n            ;shapefn \#(rect (/ side -2) (/ side -2) side side)\\n            shapefn square\\n            rot (- (* (/ mouseX width) 6.28) 3.14)\\n            sx (/ mouseY (* 1.05 height))\\n            sy sx\\n            tx (* sx side)\\n            ty 0.0]\\n        (translate (/ side 2) (/ side 2))\\n        (translate (/ width 2) (/ width 2))\\n        (scale (/ width 2) (/ width 2))\\n        (fill 0 255 0 32) \\n        (recurse shapefn rot tx ty sx sy)\\n        (fill 0 0 255 32)\\n        (recurse shapefn (* rot 2) (- tx) (- ty) sx sy)))\\n  (defsketch example\\n      \:title \\"Recursion\\"\\n      \:renderer \:opengl\\n      \:setup setup\\n      \:draw draw_kaleid\\n      \:mouse-moved mouse-moved\\n      \:size [width height])))\\n(in-ns 'user)" "(-main)" "(ns contextual.core)" "(-main)" "(defn rule [& {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  nil)" "(rule 1)" "(rule \:xscale 1)" "(defn rule [subrule\\n            & {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  nil)" "(rule 1)" "(rule foo)" "(rule 'foo)" "(rule 'foo \:xscale 1 \:yscale 2)" "(rule 'foo { \:xscale 1 \:yscale 2 })" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  nil)" "(rule 'foo { \:xscale 1 \:yscale 2 })" "(defstruct xform \:xscale \:yscale \:scale \:xtrans \:ytrans \:rotate \:xshear\\n  \:yshear \:hue \:sat \:brightness \:alpha)" "(struct xform \:xscale 2)" "xform" "(rule 'foo xform)" "(rule 'foo 'xform)" "(rule 'foo {\:xscale 1 \:yscale 1})" "(rule 'foo {\:xscale 1 \:foo 1})" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (print xscale))" "(rule 'foo {\:xscale 1})" "(rule 'foo xform)" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (keys))" "(rule 'foo xform)" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (xscale))" "(rule 'foo xform)" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (print xscale))" "(rule 'foo xform)" "(defn foo [s {\:as args} {\:or foo 1}] args)" "(defn foo [{\:as args} {\:or foo 1}] args)" "(defn foo [s & {\:as args} {\:or foo 1}] args)" "(defn foo [& {\:as args}] args)" "(defn foo [& {\:as args} {\:or foo 1}] args)" "(defn foo [& {\:as args \:or foo 1}] args)" "(defn foo [& {\:as args \:or {foo 1}}] args)" "(foo \:bar 1)" "(foo)" "(defn foo [{\:as args \:or {foo 1}}] args)" "(foo)" "(foo { })" "(foo { \:bar 1 })" "(let [{a \:a, b \:b, c \:c, \:as m \:or {a 2 b 3}} {\:a 5 \:c 6}]\\n  [a b c m])" "(let [{a \:a, b \:b, c \:c, \:as m \:or {a 2 b 3}} {\:c 6}]\\n  [a b c m])" "(defn foo [& {\:keys [foo bar] \:as args \:or {foo 1}}] args)" "(foo { })" "(foo { \:bar 1 })" "(foo)" "(foo \:bar 1)" "(defn foo [{\:keys [foo bar] \:as args \:or {foo 1}}] args)" "(foo)" "(foo 1)" "(foo \:bar 1)" "(foo { })" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n             \:as args\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (print args))" "(rule 'foo)" "(rule 'foo { })" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (print args))" "(defn rule [subrule\\n            {\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                      hue sat brightness alpha]\\n               \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n                     xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n  (print xscale))" "(rule 'foo { })" "(def someshape (othershape { \:xscale 0.5 \:yscale 0.5 \:xtrans 1 \:ytrans 1 }))" "(+ 1 2)" "(defn rule2 [subrule {\:as args}]\\n  (let [{\:keys [xscale yscale scale xtrans ytrans rotate xshear yshear\\n                hue sat brightness alpha]\\n         \:or { xscale 1 yscale 1 scale 1 xtrans 0 ytrans 0 rotate 0\\n               xshear 0 yshear 0 hue 0 sat 0 brightness 0 alpha 0 }}]\\n    (print xscale)))" "{\:a 9}" "(merge {\:a 9} {\:a 8})" "(defn rule2 [subrule {\:as args}]\\n  (merge args\\n    {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0 \:xshear 0\\n     \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}))" "(rule2 'foo \:xscale 1)" "(rule2 'foo { \:xscale 1 })" "(defn rule [subrule {\:as args}]\\n  (merge args\\n    {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0 \:xshear 0\\n     \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}))" "(def someshape (rule othershape { \:xscale 0.5 \:yscale 0.5 \:xtrans 1 \:ytrans 1 }\\n                     moreshapes { \:xscale 0.25 \:yscale 0.25 }))" "(def othershape nil)" "(def moreshapes nil)" "(def someshape (rule othershape { \:xscale 0.5 \:yscale 0.5 \:xtrans 1 \:ytrans 1 }\\n                     moreshapes { \:xscale 0.25 \:yscale 0.25 }))" "(def recursive_shape (rule recursive_shape { \:xscale 0.25 \:yscale 0.25 }))" "(cons 5 6)" "(cons 5 (5))" "(cons 5 '(5))" "(defn rule [subrule {\:as args}]\\n  (list\\n    subrule\\n    (merge args\\n           {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n            \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0})))" "(def recursive_shape (rule recursive_shape { \:xscale 0.25 \:yscale 0.25 }))" "recursive_shape" "(defn rule [subrule {\:as args}]\\n  (list\\n    subrule\\n    (merge {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n            \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}\\n           args)))" "(def recursive_shape (rule recursive_shape { \:xscale 0.25 \:yscale 0.25 }))" "recursive_shape" "(def recursive_shape2 (rule recursive_shape2 { \:xscale 0.25 \:yscale 0.25 }))" "recursive_shape2" "(first recursive_shape2)" "(def recursive_shape2 (rule recursive_shape3 { \:xscale 0.25 \:yscale 0.25 }))" "(def recursive_shape2 (rule recursive_shape2 { \:xscale 0.25 \:yscale 0.25 }))" "(first recursive_shape2)" "(apply \#(+ x 10) (1 2 3))" "(apply (fn x (+ x 10)) (1 2 3))" "(apply (fn x (+ x 10)) '(1 2 3))" "(apply (fn x (+ x 10)) [1 2 3])" "(fn x (+ x 10))" "(fn [x] (+ x 10))" "(apply (fn [x] (+ x 10)) (1 2 3))" "> (apply (fn [x] (+ x 10)) '(1 2 3))" "> (apply (fn [x] (+ x 10)) [1 2 3])" "(doc map)" "(map \#([x] (+ x 10)) (1 2 3))" "\#(x (+ x 10))" "\#(+ x 10)" "\#([x] (+ x 10))" "((fn [x] (+ x 10)) 20)" "(map (fn [x] (+ x 10)) (1 2 3))" "> (apply (fn x (+ x 10)) (1 2 3))\\n(map (fn [x] (+ x 10)) (1 2 3))" "(map (fn [x] (+ x 10)) '(1 2 3))" "(defn rule [&args]\\n  (map\\n    (fn [pair]\\n      (let [subrule {\:as xform}]\\n        (list subrule xform)))\\n    args))" "(defn unpack [pair]\\n  (let [[subrule {\:as xform}] pair]\\n        (list subrule xform)))" "(defn rule [&args]\\n  (map\\n    unpack\\n    args))" "(defn rule [&arglist]\\n  (map\\n    unpack\\n    arglist))" "(defn test [&arglist] arglist)" "(defn test [& arglist] arglist)" "(defn rule [& arglist]\\n  (map\\n    (fn unpack [pair]\\n      (let [[subrule {\:as xform}] pair]\\n        (list subrule xform)))\\n    arglist))" "(rule [('foo {\:xscale 1})\\n       ('bar {\:yscale 2})])" "    (fn unpack [pair]\\n      (let [[subrule {\:as xform}] pair]\\n        (list subrule xform)))" "(defn rule [& arglist]\\n  (map\\n    (fn [pair]\\n      (let [[subrule {\:as xform}] pair]\\n        (list subrule xform)))\\n    arglist))" "(rule [('foo {\:xscale 1})\\n          ('bar {\:yscale 2})])" "(defn unpack [pair]\\n  (let [[subrule {\:as xform}] pair]\\n    (list subrule xform)))" "(unpack '(foo {\:xscale 1}))" "(defn unpack [pair]\\n  (let [[subrule {\:as xform}] pair]\\n    (list\\n      subrule\\n      (merge {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n              \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}\\n             xform))))" "(unpack '(foo {\:xscale 1}))" "(defn rule [& arglist]\\n  (map unpack arglist))" "(rule [('foo {\:xscale 1})\\n             ('bar {\:yscale 2})])" "(defn rule [& arglist] arglist)" "(rule [('foo {\:xscale 1})\\n             ('bar {\:yscale 2})])" "(rule 1 2 3)" "(rule 'foo {\:xscale 1})" "(defn rule [& arglist]\\n  (map unpack arglist))" "(rule 'foo {\:xscale 1})" "(defn rule [& arglist]\\n  (print arglist)\\n  (map unpack arglist))" "(rule 'foo {\:xscale 1})" "(rule 'foo {\:xscale 1} 'bar {\:xscale 2})" "(foo ({\:xscale 1} bar) ({\:xscale 2}))" " (rule ('foo {\:xscale 1}) ('bar {\:xscale 2}))" " (rule ['foo {\:xscale 1} 'bar {\:xscale 2}])" "('foo {\:xscale 1})" "(rule '(foo {\:xscale 1}) '(bar {\:xscale 2}))" "(rule [foo {\:xscale 1}])" "(defn rule [& arglist]\\n  (map (fn [pair]\\n         (let [[subrule {\:as xform}] pair]\\n           (list\\n             subrule\\n             (merge {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n                     \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}\\n                    xform))))\\n       arglist))" "(def othershape nil)" "(def moreshapes nil)" "(def shapefoo (rule-choose 0.1 shape1\\n                           0.2 shape2))" "(def someshape (rule (othershape { \:xscale 0.5 \:yscale 0.5 \:xtrans 1 \:ytrans 1 })\\n                     (moreshapes { \:xscale 0.25 \:yscale 0.25 })))" "(def shapefoo (rule-choose 0.1 shape1\\n                           0.2 shape2))" "(def someshape (rule '(othershape { \:xscale 0.5 \:yscale 0.5 \:xtrans 1 \:ytrans 1 })\\n                     '(moreshapes { \:xscale 0.25 \:yscale 0.25 })))" "someshape" "(partition 2 [1 2 3 4 5 6])" "(defn rule [& arglist]\\n  (map (fn [pair]\\n         (let [[subrule {\:as xform}] pair]\\n           (list\\n             subrule\\n             (merge {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n                     \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}\\n                    xform))))\\n       (partition 2 arglist)))" "(rule othershape { \:xscale 1 } moreshapes { \:xscale 1 } )" "(defn default-xform [{\:as xform}]\\n  (merge {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n          \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}\\n         xform))" "(default-xform { \:xscale 1 })" "(default-xform { \:xscale 1 \:yscale 10 })" "(default-xform \:xscale 1)" "(def othershape nil)" "(defn rule [& arglist]\\n  (map (fn [pair]\\n         (let [[subrule xform] pair]\\n           (list subrule (default-xform xform))))\\n;             subrule\\n;             (merge {\:xscale 1 \:yscale 1 \:scale 1 \:xtrans 0 \:ytrans 0 \:rotate 0\\n;                     \:xshear 0 \:yshear 0 \:hue 0 \:sat 0 \:brightness 0 \:alpha 0}\\n;                    xform))))\\n       (partition 2 arglist)))" "(rule othershape { \:xscale 0.5 } moreshapes { \:xscale 1 } )" "(let [expr '(+ a b)\\n      a 10\\n      b 20]\\n  (eval expr))" "(eval '(+ 1 2))" "(let [expr '(+ 1 2)] (eval expr))" "(let [a 1\\n      expr '(+ a 1)]\\n  (eval expr))" "(symbol square)" "(symbol \\"square\\")" "(def square (symbol \\"square\\"))" "(def circle (symbol \\"circle\\"))" "(def triangle (symbol \\"triangle\\"))" "(def \:\:triangle (symbol \\"triangle\\"))" "(doc use)" "recursive-shape2" "(def recursive_shape2 (rule recursive_shape2 { \:xscale 0.25 \:yscale 0.25 }))" "(declare recursive_shape3)" "(def recursive_shape3 (rule recursive_shape3 { \:xscale 0.25 \:yscale 0.25 }))" "recursive_shape2" "recursive_shape3" "(first recursive_shape3)" "(first (first recursive_shape3))" "(first (first (first recursive_shape3)))" "(help iterate)" "(doc iterate)" "(bound? a)" "(bound? 'a)" "(defn rule [& arglist]\\n  ; Split 'arglist' into subrule/xform pairs; use 'xform' to override defaults\:\\n  (map (fn [pair] (let [[subrule xform] pair]\\n                    (list (default-xform xform) subrule (bound? subrule))))\\n       (partition 2 arglist)))" "(def recursive_shape4 (rule recursive_shape4 { \:xscale 0.25 \:yscale 0.25 }))" "recursive_shape4" "(defn rule [& arglist]\\n  ; Split 'arglist' into subrule/xform pairs; use 'xform' to override defaults\:\\n  (map (fn [pair] (let [[subrule xform] pair]\\n                    (list (default-xform xform) subrule (bound? 'subrule))))\\n       (partition 2 arglist)))" "(def recursive_shape5 (rule recursive_shape5 { \:xscale 0.25 \:yscale 0.25 }))" "(recursive_shape5)" "recursive_shape5" "(first recursive_shape5)" "(rest recursive_shape5)" "(bound? recursive_shape5)" "(doc var)" "(defn rule [& arglist]\\n  ; Split 'arglist' into subrule/xform pairs; use 'xform' to override defaults\:\\n  (map (fn [pair] (let [[subrule xform] pair]\\n                    (list (default-xform xform) subrule)))\\n       (partition 2 arglist)))" "(def recursive_shape6 (rule recursive_shape6 { \:xscale 0.25 \:yscale 0.25 }))" "recursive_shape6" "(+ 1 2)" "(in-ns 'contextual.core)\\n(ns contextual.core\\n  (\:use quil.core))\\n(in-ns 'user)" "nil" "(doc iter)" "(use 'clojure.repl)" "(doc iter)" "(doc doc)" "(doc iterate)" "(iterate [(fn [x] (+ x 1)) 1])" "(iterate (fn [x] (+ x 1)) 1)" "(def lazy (iterate (fn [x] (+ x 1)) 1))" "(first lazy)" "(\:foo 4)" "{\:foo 4}" "(assoc {\:foo 4} foo 5)" "(assoc {\:foo 4} 'foo 5)" "(assoc {\:foo 4} \:foo 5)" "({\:foo 4} \:foo)" "(doc if)" "(in-ns 'contextual.core)\\n(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x) xform))\\n    xform))\\n(in-ns 'user)" "(lazify-xform {\:xscale 0.5})" "(in-ns 'contextual.core)\\n(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x) xform))\\n    xform))\\n(in-ns 'user)" "(in-ns 'contextual.core)\\n(ns contextual.core\\n  (\:use quil.core))\\n(in-ns 'user)" "(in-ns 'contextual.core)\\n(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x) xform))\\n    xform))\\n(in-ns 'user)" "\\nlazify-form" "(in-ns 'contextual.core)\\n(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x) xform))\\n    xform))\\n(in-ns 'user)" "(in-ns 'contextual.core)\\n(ns contextual.core\\n  (\:use quil.core))\\n(in-ns 'user)" "\\nlazify-xform" "\:\:lazify-xform" "(\:\:lazify-xform {\:xscale 1})" "(def test 1)" "(def test-sym 1)" "test-sym" "(reset\! lazify-xform)" "(in-ns 'contextual.core)\\n(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x) xform))\\n    xform))\\n(in-ns 'user)" "(use 'contextual.core)" "(ns contextual.core)" "(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x) xform))\\n    xform))" "(set\! *print-length* 103)" "(lazify-xform { \:xscale 1 })" "(defn lazify-xform [xform]\\n  (if (nil? (xform \:child))\\n    (iterate (fn [x] (assoc x \:child x)) xform)\\n    xform))" "(lazify-xform { \:xscale 1 \:child nil })" "(doc cons)" "(def t ())" "(cons t t)" "(doc lazy-seq)" "(doc recur)" "(doc lazy-cat)" "(doc lazy-seq)"]
eclipse.preferences.version=1
